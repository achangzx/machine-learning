协同过滤算法：Collaborative filtering algorithm
  适合问题：推荐系统
  实现原理（以电影推荐为例）：
    这是第一种协同过滤算法，传统算法，需要对公式推导正确，还有就是了解各个参数的行列都是什么属性，还有就是行列的个数，这个是算法的核心，但是算法的实现过程比较麻烦，属于入门级别的算法
    def cofi_cost_func(X, W, b, Y, R, lambda_):
    """
    Returns the cost for the content-based filtering
    Args:
      X (ndarray (num_movies,num_features)): matrix of item features
      W (ndarray (num_users,num_features)) : matrix of user parameters
      b (ndarray (1, num_users)            : vector of user parameters
      Y (ndarray (num_movies,num_users)    : matrix of user ratings of movies
      R (ndarray (num_movies,num_users)    : matrix, where R(i, j) = 1 if the i-th movies was rated by the j-th user
      lambda_ (float): regularization parameter
    Returns:
      J (float) : Cost
    """
    nm, nu = Y.shape
    m,n=X.shape
    J = 0 loss=0
    for j in range(nu):
        for i in range(nm):
            loss=0.5*R[i,j]*((np.dot(W[j,:],X[i,:])+b[0,j]-Y[i,j])**2)+loss     #充分了解w，x的属性，也就是我们的回归参数包括行列的个数，行列均代表什么含义，算法的核心********   
    regularization1=0
    regularization2=0
    for j in range(nu):
        for k in range(n):
            regularization1=0.5*lambda_*(W[j,k]**2)+regularization1
    for i in range(nm):
        for k in range(n):
            regularization2=0.5*lambda_*(X[i,k]**2)+regularization2
    J=loss+regularization1+regularization2 

    return J    
    
    
    
    以下是第二种协同过滤算法利用tensorflow实现，通过矩阵进行实现，大大简化计算过程，但是前提是对于各个参数变量的属性都做了非常清楚的了解，还有就是tensorflow中一些常用函数
    优点很明显就是可以不用对参数w，x的行列进行编码迭代，因为通过矩阵的形式非常简单，但是如何实现比较麻烦。进阶算法
    def cofi_cost_func(X, W, b, Y, R, lambda_):
    """
    Returns the cost for the content-based filtering
    Args:
      X (ndarray (num_movies,num_features)): matrix of item features
      W (ndarray (num_users,num_features)) : matrix of user parameters
      b (ndarray (1, num_users)            : vector of user parameters
      Y (ndarray (num_movies,num_users)    : matrix of user ratings of movies
      R (ndarray (num_movies,num_users)    : matrix, where R(i, j) = 1 if the i-th movies was rated by the j-th user
      lambda_ (float): regularization parameter
    Returns:
      J (float) : Cost
    """
    nm, nu = Y.shape
    m,n=X.shape
    J = 0   
    j=(tf.linalg.matmul(X,tf.transpose(W))+b-Y)*R                                           #tf.linalg.matmul（）表示进行矩阵乘法运算（和线性代数中完全相同），tf.transpose（）输出矩阵的转置
    J=0.5*tf.reduce_sum(j**2)+0.5*lambda_*(tf.reduce_sum(X**2)+tf.reduce_sum(W**2))         #tf.reduce_sum（）输出是矩阵的每一项相加

