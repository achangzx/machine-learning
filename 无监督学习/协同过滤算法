协同过滤算法：Collaborative filtering algorithm
  适合问题：推荐系统
  实现原理（以电影推荐为例）：
    这是第一种协同过滤算法，
    def cofi_cost_func(X, W, b, Y, R, lambda_):
    """
    Returns the cost for the content-based filtering
    Args:
      X (ndarray (num_movies,num_features)): matrix of item features
      W (ndarray (num_users,num_features)) : matrix of user parameters
      b (ndarray (1, num_users)            : vector of user parameters
      Y (ndarray (num_movies,num_users)    : matrix of user ratings of movies
      R (ndarray (num_movies,num_users)    : matrix, where R(i, j) = 1 if the i-th movies was rated by the j-th user
      lambda_ (float): regularization parameter
    Returns:
      J (float) : Cost
    """
    nm, nu = Y.shape
    m,n=X.shape
    J = 0 loss=0
    for j in range(nu):
        for i in range(nm):
            loss=0.5*R[i,j]*((np.dot(W[j,:],X[i,:])+b[0,j]-Y[i,j])**2)+loss        
    regularization1=0
    regularization2=0
    for j in range(nu):
        for k in range(n):
            regularization1=0.5*lambda_*(W[j,k]**2)+regularization1
    for i in range(nm):
        for k in range(n):
            regularization2=0.5*lambda_*(X[i,k]**2)+regularization2
    J=loss+regularization1+regularization2 

    return J    
    
    
    
    以下是第二种协同过滤算法利用tensorflow实现def cofi_cost_func(X, W, b, Y, R, lambda_):
    """
    Returns the cost for the content-based filtering
    Args:
      X (ndarray (num_movies,num_features)): matrix of item features
      W (ndarray (num_users,num_features)) : matrix of user parameters
      b (ndarray (1, num_users)            : vector of user parameters
      Y (ndarray (num_movies,num_users)    : matrix of user ratings of movies
      R (ndarray (num_movies,num_users)    : matrix, where R(i, j) = 1 if the i-th movies was rated by the j-th user
      lambda_ (float): regularization parameter
    Returns:
      J (float) : Cost
    """
    nm, nu = Y.shape
    m,n=X.shape
    J = 0   
    j=(tf.linalg.matmul(X,tf.transpose(W))+b-Y)*R
    J=0.5*tf.reduce_sum(j**2)+0.5*lambda_*(tf.reduce_sum(X**2)+tf.reduce_sum(W**2))
